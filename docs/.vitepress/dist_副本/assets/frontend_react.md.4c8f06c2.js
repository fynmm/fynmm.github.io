import{_ as e,o as t,c,S as o}from"./chunks/framework.f15d8f8c.js";const E=JSON.parse('{"title":"react面试题","description":"react 面试题 前端 js","frontmatter":{"lang":"zh-CN","title":"react面试题","description":"react 面试题 前端 js"},"headers":[],"relativePath":"frontend/react.md","filePath":"frontend/react.md"}'),a={name:"frontend/react.md"},f=o('<h1 id="react面试题" tabindex="-1">React面试题 <a class="header-anchor" href="#react面试题" aria-label="Permalink to &quot;React面试题&quot;">​</a></h1><h2 id="useeffect和uselayouteffect有什么区别" tabindex="-1">useEffect和useLayoutEffect有什么区别 <a class="header-anchor" href="#useeffect和uselayouteffect有什么区别" aria-label="Permalink to &quot;useEffect和useLayoutEffect有什么区别&quot;">​</a></h2><p><code>useEffect</code>和<code>useLayoutEffect</code>都是<code>React Hooks</code>中的函数，用于处理副作用。但是，它们之间存在一些主要区别：</p><ul><li>执行时间：<code>useEffect</code>在每次渲染后异步执行，不会阻塞浏览器更新屏幕，使得你的应用看起来响应更快。相反，<code>useLayoutEffect</code>在浏览器布局与绘制之后同步执行，可能会导致一些性能问题。</li><li>使用场景：由于<code>useEffect</code>是异步的，所以如果你需要等待DOM更新完成后再进行操作（例如获取元素的尺寸或位置），那么就需要使用<code>useLayoutEffect</code>。而对于大部分网络请求或者订阅事件这样的异步操作，则推荐使用<code>useEffect</code>。</li><li>服务器端渲染(SSR)：在服务器端渲染时，由于没有DOM环境，所以<code>useLayoutEffect</code>会直接跳过不执行。而<code>useEffect</code>也不会执行，但可以设置为在客户端再次渲染时执行。</li><li>总结来说，在大多数情况下我们都应该使用 <code>useEffect</code>, 但当我们需要同步修改 DOM，并且希望用户在渲染前看到更新结果时, 应该使用 <code>useLayoutEffect</code>.</li></ul>',4),s=[f];function d(r,u,i,n,l,_){return t(),c("div",null,s)}const p=e(a,[["render",d]]);export{E as __pageData,p as default};
